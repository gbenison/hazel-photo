#!/bin/sh
#-*- scheme -*-
#
#    Copyright (C) 2012 Greg Benison
#   
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#   
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#   
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#  

export GUILE_LOAD_PATH=$GUILE_LOAD_PATH:`pwd`;
export LTDL_LIBRARY_PATH=$LTDL_LIBRARY_PATH:`pwd`;
export GUILE_WARN_DEPRECATED=no;
exec guile --listen -s $0 $@ 2>>guile-error.log

!#

(use-modules (srfi srfi-1)
	     (sxml simple)
	     (ice-9 regex)
	     (ice-9 pretty-print)
	     (web request)
	     (web uri)
	     (web server))

(define image-dir "images")
(define image-server-base-url "http://localhost:8081/")
(define thumbnail-dir "thumbnails")
(define thumbnail-cmd "/usr/bin/convert")
(define thumbnail-args '("-resize" "80x80"))

(define image-suffixes '("jpg" "JPEG" "JPG" "png" "PNG" "tif" "tiff" "TIFF"))

(define (image-file? fname)
  (any
   (lambda (suffix)
     (string-match (string-append "." suffix) fname))
   image-suffixes))

(define (replace-extension fname new-ext)
  (let ((my-match (string-match "[.][^./]*$" fname)))
    (string-append
     (if my-match (match:prefix my-match) fname)
     "." new-ext)))

(define (ensure-thumbnail folder image-fname)
  (let ((image-full-path     (string-join `(,image-dir ,folder ,image-fname) "/"))
	(thumbnail-full-path (string-join `(,thumbnail-dir
					    ,folder
					    ,(replace-extension image-fname "jpg"))
					  "/")))
    ;; FIXME vulnerable to a regular file existing with this name.
    (if (not (and (file-exists? (dirname thumbnail-full-path))
		  (file-is-directory? (dirname thumbnail-full-path))))
	(mkdir (dirname thumbnail-full-path)))
    (if (not (file-exists? thumbnail-full-path))
	(apply system*
	       (append (cons thumbnail-cmd
			     thumbnail-args)
		       (list image-full-path
			     thumbnail-full-path))))))

(define (all-files dirname)
  (let ((handle (opendir dirname)))
    (let loop ((result '()))
      (let ((next (readdir handle)))
	(if (eof-object? next)
	    result
	    (loop (cons next result)))))))

(define (is-image-folder? dirname)
  (any image-file?
       (map (prepend-path (list dirname))(all-files dirname))))

(define (prepend-path path)
  (lambda (fname)
    (string-join (append path (list fname)) "/")))

(define (all-image-folders)
  (define (is-image-folder-name? fname)
    (let ((full-path (string-append image-dir "/" fname)))
      (and (file-exists?       full-path)
	   (file-is-directory? full-path)
	   (is-image-folder?   full-path))))
  (filter is-image-folder-name? (all-files image-dir)))

(define (lookup-image-folder uri-path)
  (let ((fname (uri-path->path (cons image-dir uri-path))))
    (and (file-exists? fname)
	 (file-is-directory? fname)
	 fname)))

(define (sxml->text sxml)
  (with-output-to-string
    (lambda () (sxml->xml sxml))))

(define (folder-not-found-page path)
  (as-html-reply
   (with-standard-header
    `(body (p "Folder " ,path " does not exist.  Try one of these:")
	   (ul ,(map image-folder->li (all-image-folders)))))))

(define (folder-page uri-path)
  (let ((folder-path (lookup-image-folder uri-path)))
    (define (image->li image-fname)
      (let* ((full-path (path->uri (list (basename folder-path) image-fname)))
	     (image-url (string-append image-server-base-url full-path)))
	`(li (a (@ (href ,image-url))
		(img (@ (src ,image-url)))))))
    (if folder-path
	(as-html-reply
	 (with-standard-header
	  `(body
	    (h2 ,(car uri-path))
	    (ul ,(map image->li
		      (filter image-file?
			      (all-files folder-path)))))))
	(folder-not-found-page uri-path))))

(define (unknown-request)
  (as-html-reply
   (with-standard-header
    `(body (p "Can't get thar from here.")
	   (a (@ (href "/")) "HOME")))))

(define (path->fname path)
  (string-join path "/"))

(define (path->uri path)
  (string-join (map uri-encode path) "/"))

(define (uri-path->path uri-path)
  (string-join (map uri-decode uri-path) "/"))

(define (request-path-components request)
  (split-and-decode-uri-path (uri-path (request-uri request))))


(define (as-html-reply sxml)
  (values '((content-type . (text/html)))
	  (sxml->text sxml)))

(define (with-standard-header body)
  `(html
    (head (title "HazelPhoto 0.1")
	  (link (@ (rel "stylesheet")(type "text/css")(href "style.css"))))
    ,body))

(define (char-alphanumeric? c)
  (or (char-alphabetic? c)
      (char-numeric? c)))

;; FIXME need to add thumbnail
(define (image-folder->li folder-name)
  `(li
    (a (@ (href ,(uri-encode (basename folder-name)))) ,folder-name)))

(define (landing-page)
  (as-html-reply
   (with-standard-header
    `(body
      (ul
       ,(map image-folder->li (all-image-folders)))))))

(define (with-error-handler thunk)
  (catch #t thunk
    (lambda args
      (values '((content-type . (text/plain)))
	      (with-output-to-string
		(lambda () (pretty-print args)))))))

(define (hazel-photo-handler request request-body)
  (with-error-handler
   (lambda ()
     (let ((uri-path (request-path-components request)))
       (cond
	((null? uri-path)             (landing-page))
	((equal? 1 (length uri-path)) (folder-page uri-path))
	((equal? 2 (length uri-path)) (image-page  uri-path))
	(else                         (unknown-request)))))))

(run-server hazel-photo-handler 'http)