#!/bin/sh
#-*- scheme -*-
#
#    Copyright (C) 2012 Greg Benison
#   
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#   
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#   
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#  

export GUILE_LOAD_PATH=$GUILE_LOAD_PATH:`pwd`;
export LTDL_LIBRARY_PATH=$LTDL_LIBRARY_PATH:`pwd`;
export GUILE_WARN_DEPRECATED=no;
exec guile --listen -s $0 $@ 2>>guile-error.log

!#

(use-modules (srfi srfi-1)
	     (sxml simple)
	     (ice-9 regex)
	     (ice-9 pretty-print)
	     (ice-9 receive)
	     (web request)
	     (web uri)
	     (web server))

(define image-server-base-url
  (or (getenv "HAZEL_MEDIA_URL") "http://localhost:8081/"))
(define socket-file-name
  (or (getenv "HAZEL_SOCK_PATH") "/tmp/test.sock"))
(define media-dir
  (or (getenv "HAZEL_MEDIA_DIR") "media"))
(define image-dir      (string-append media-dir "/images"))
(define derivative-cmd "/usr/bin/convert")

(define image-suffixes '("jpg" "JPEG" "JPG" "png" "PNG" "tif" "tiff" "TIFF"))
(define standard-derivative-extension "jpg")

(define (image-file? fname)
  (any
   (lambda (suffix)
     (string-match (string-append "." suffix) fname))
   image-suffixes))

(define (replace-extension fname new-ext)
  (let ((my-match (string-match "[.][^./]*$" fname)))
    (string-append
     (if my-match (match:prefix my-match) fname)
     "." new-ext)))

(define (string-match-with? target)
  (lambda (str) (equal? str target)))

(define (take/max elems n)
  (cond ((null? elems) '())
	((< n 1)
	 '())
	(else (cons (car elems)
		    (take/max (cdr elems) (- n 1))))))

;; Returns three values:
;; 1) The longest prefix of 'elems' for none of which (pred elem) is true,
;;    in reverse order;
;; 2) The first element for which (pred elem) is true;
;; 3) The remaining elements.
(define (pick-around pred elems)
  (let go ((init '())
	   (rest elems))
    (cond ((null? rest)
	   (values init #f '()))
	  ((pred (car rest))
	   (values init (car rest) (cdr rest)))
	  (else (go (cons (car rest) init)
		    (cdr rest))))))

;; Like 'pick-around', but defaults to the first list member if none match.
(define (pick-around/default pred elems)
  (receive (init elem tail)
      (pick-around pred elems)
    (if elem (values init elem tail)
	(values '()
		(car elems)
		(cdr elems)))))

(define (derivative-uri type)
  (lambda (folder image-fname)
    (string-append
     image-server-base-url
     (path->uri (list type
		      (basename folder)
		      (replace-extension image-fname
					 standard-derivative-extension))))))

(define (ensure-derivative-image dest-dir convert-args)
  (let ((->uri (derivative-uri dest-dir)))
    (lambda (folder image-fname)
      (let ((image-full-path     (string-join
				  `(,image-dir ,folder ,image-fname) "/"))
	    (derivative-full-path (string-join `(,media-dir
						 ,dest-dir
						 ,folder
						 ,(replace-extension
						   image-fname
						   standard-derivative-extension))
					       "/")))
	;; FIXME vulnerable to a regular file existing with this name.
	(if (not (and (file-exists? (dirname derivative-full-path))
		      (file-is-directory? (dirname derivative-full-path))))
	    (mkdir (dirname derivative-full-path)))
	(if (not (file-exists? derivative-full-path))
	    (apply system*
		   (append (cons derivative-cmd
				 convert-args)
			   (list image-full-path
				 derivative-full-path))))
	(->uri folder image-fname)))))

(define ensure-thumbnail
  (ensure-derivative-image "thumbnails" '("-resize" "80x80")))
(define ensure-feature
  (ensure-derivative-image "feature" '("-resize" "600x520>")))

(define (make-thumbnail folder-name image-name)
  `(img (@ (src ,(ensure-thumbnail folder-name image-name)))))

(define (all-files dirname)
  (let ((handle (opendir dirname)))
    (let loop ((result '()))
      (let ((next (readdir handle)))
	(if (eof-object? next)
	    result
	    (loop (cons next result)))))))

(define (is-image-folder? dirname)
  (any image-file?
       (map (prepend-path (list dirname))(all-files dirname))))

(define (prepend-path path)
  (lambda (fname)
    (string-join (append path (list fname)) "/")))

(define (all-image-folders)
  (define (is-image-folder-name? fname)
    (let ((full-path (string-append image-dir "/" fname)))
      (and (file-exists?       full-path)
	   (file-is-directory? full-path)
	   (is-image-folder?   full-path))))
  (sort
   (filter is-image-folder-name? (all-files image-dir))
   string<?))

(define (lookup-image-folder uri-path)
  (let ((fname (uri-path->path (list image-dir (car uri-path)))))
    (and (file-exists? fname)
	 (file-is-directory? fname)
	 fname)))

(define (sxml->text sxml)
  (with-output-to-string
    (lambda () (sxml->xml sxml))))

(define (folder-not-found-page path)
  (as-html-reply
   (with-standard-header
    `(body (p "Folder " ,path " does not exist.  Try one of these:")
	   (ul ,(map image-folder->li (all-image-folders)))))))

(define (folder-page uri-path)
  (let* ((folder-name (uri-decode (first uri-path)))
	 (selected-image-name  (and (> (length uri-path) 1)
				    (uri-decode (second uri-path))))
	 (folder-path (string-append image-dir "/" folder-name)))
    (define* (li-for image-name #:optional selected)
      `(li (a (@ (href ,(path->uri (list "" folder-name image-name)))
		 ,@(if selected
		       '((class "selected"))
		       '()))
	      ,(make-thumbnail folder-name image-name))))
    (if (not (and (file-exists? folder-path)
		  (file-is-directory? folder-path)))
	(folder-not-found-page uri-path)
	(receive (prev-images
		  selected-image
		  next-images)
	    (pick-around/default (string-match-with? selected-image-name)
				 (all-image-names folder-name))
	  (as-html-reply
	   (with-standard-header
	    `(body
	      (div (@ (class "sidebar"))
	       (h2 ,(car uri-path))
	       (ul (@ (class "thumbnails gallery"))
		   ,@(map li-for (reverse (take/max prev-images 5)))
		   ,(li-for selected-image 'selected)
		   ,@(map li-for (take/max next-images 5))))
	      (div (@ (class "featured"))
		   (span
		    ,@(if (null? prev-images)
			  '()
			  `((a (@ (href ,(path->uri (list "" folder-name (car prev-images)))))
			       "<")))
		    ,(img-element-for folder-name selected-image)
		    ,@(if (null? next-images)
			  '()
			  `((a (@ (href ,(path->uri (list "" folder-name (car next-images)))))
			       ">"))))))))))))

(define (unknown-request)
  (as-html-reply
   (with-standard-header
    `(body (p "Can't get thar from here.")
	   (a (@ (href "/")) "HOME")))))

(define (path->fname path)
  (string-join path "/"))

(define (path->uri path)
  (string-join (map uri-encode path) "/"))

(define (uri-path->path uri-path)
  (string-join (map uri-decode uri-path) "/"))

(define (request-path-components request)
  (split-and-decode-uri-path (uri-path (request-uri request))))


(define (as-html-reply sxml)
  (values '((content-type . (text/html)))
	  (sxml->text sxml)))

(define (with-standard-header . body-elements)
  `(html
    (head (title "HazelPhoto 0.1")
	  (link (@ (rel "stylesheet")
		   (type "text/css")
		   (href ,(string-append image-server-base-url
					 "style.css")))))
    (body
     (div (@ (id "nav"))
	  (a (@ (href "/"))
	     "HazelPhoto 0.1"))
     ,@body-elements)))

(define (char-alphanumeric? c)
  (or (char-alphabetic? c)
      (char-numeric? c)))

(define (all-image-names folder-name)
  (sort
   (map basename
	(filter image-file?
		(all-files (string-append image-dir "/" folder-name))))
   string<?))

(define (image-uri folder-name image-name)
  (string-append
   image-server-base-url
   (path->uri (list "images"
		    (basename folder-name)
		    (basename image-name)))))

(define (img-element-for folder-name image-name)
  `(a (@ (href ,(image-uri folder-name image-name)))
    (img (@ (src ,(ensure-feature folder-name image-name))))))

(define (folder->thumbnail-ul folder-name)
  `(ul (@ (class "thumbnails gallery"))
    ,(map (lambda (image-name)
	    `(li ,(make-thumbnail folder-name image-name)))
	  (take/max (all-image-names folder-name) 6))))

(define (image-folder->li folder-name)
  `(li (@ (class "folder-link"))
       (a (@ (href ,(uri-encode (basename folder-name))))
	  (div
	   (h2 ,folder-name)
	   ,(folder->thumbnail-ul folder-name)
	   (div (@ (class "expander")))))))

(define (landing-page)
  (as-html-reply
   (with-standard-header
    `(body
      (ul (@ (class "folder-list"))
	  ,(map image-folder->li (all-image-folders)))))))

(define (with-error-handler thunk)
  (catch #t thunk
    (lambda args
      (values '((content-type . (text/plain)))
	      (with-output-to-string
		(lambda () (pretty-print args)))))))

(define (hazel-photo-handler request request-body)
  (with-error-handler
   (lambda ()
     (let ((uri-path (request-path-components request)))
       (cond
	((null? uri-path)             (landing-page))
	((>= (length uri-path) 1)     (folder-page uri-path))
	(else                         (unknown-request)))))))


(define (make-unix-socket fname)
  (let ((server-socket (socket PF_UNIX SOCK_STREAM 0)))
    (if (file-exists? fname) (delete-file fname))
    (bind server-socket AF_UNIX fname)
    server-socket))

(run-server hazel-photo-handler
	    'http
	    `(#:socket ,(make-unix-socket socket-file-name)))